# -*- encoding: utf-8 -*-

# Число pi [1] с произвольной точностью можно вычислить через сумму
# бесконечного знакопеременного ряда: 
# 
#   pi = 4 * (1 - 1/3 + 1/5 - 1/7 + ...)

def calc_pi_series(n):
    """Вычисляет сумму ряда pi из n членов"""
    pi = 0   # начальное приближение pi
    sign = 1 # знак следующего члена ряда
    # xrange(start, end, step) схоже с range() генерирует числа. 
    # См замечание 1.
    for i in xrange(1, 2 * n + 1, 2): # i проходит от 1 до 2*n+1 (не включая 
                                      # последний) с шагом 2
        d = 4 * (1.0 / i)
        pi += sign * d
        sign *= -1
    return pi

print "calc_pi_series(10) =", calc_pi_series(10) # 3.04183961893
print "calc_pi_series(20) =", calc_pi_series(20) # 3.09162380667
print "calc_pi_series(50) =", calc_pi_series(50) # 3.12159465259

# Слишком мало точных знаков! Напишем функцию которая явно вычисляет pi с
# точностью до определённого знака.

# Нам понадобится функция count [2] из стандартной библиотеки из модуля
# itertools.  Импортируем её в наш модуль (подробнее будет рассказано на
# лекции):
from itertools import count 
# count(st, step) генерирует числа st, st + step, st + 2 * step, ...

def calc_pi(digits):
    """Вычисляет pi с точностью до n-го знака.

    Погрешность +/- половина знака с номером digits.

    Возвращает кортеж (пи, число выполненных шагов).
    """
    pi = 0 # начальное приближение pi
    sign = 1
    for i in count(1, 2): # числа начиная с 1 и с шагом 2
        d = 4 * (1.0 / i)
        pi += sign * d
        sign *= -1

        if d < 0.5 * 10**-digits:
            # Колебания знакопеременного ряда меньше половины величины 
            # последней требующейся значащей цифры pi.
            break;
    # Возвращаем кортеж (tuple).
    return (pi, (i - 1) / 2)

for digit in xrange(6):
    print "calc_pi(" + str(digit) + ") =", calc_pi(digit)

# Замечания: 
# 
# 1. Используется функция xrange() [3] вместо функции range(). range() ---
# создаёт список из чисел, xrange() --- это _генератор_, он вычисляет каждое
# следующее число по мере работы цикла for, об этом детальней будет рассказано
# позже.  Следует использовать xrange в таких местах, т.к. при итерировании по
# большому количеству чисел создавать список из них излишне.

# Задания:
# 
# 1. Напишите функцию calc_e_series(n), которая будет вычислять сумму первых n 
# членов ряда разложения числа e [4]:
#   e = 1/0! + 1/1! + 1/2! + 1/3! + 1/4! + ...
# где символом "!" обозначен факториал.
#
# 2. Напишите функцию calc_e(digits), которая будет вычислять e с точностью
# до определённого знака. Остаток ряда оценить значением последнего 
# вычисленного приращения, т.е. ряд нужно считать до первого члена, который
# окажется меньше 0.5 * 10**-digits.
#
# 3. Дана вещественная функция:
def f(x):
    return -x**5 + 30 * x**3 - 1
# f(x) принимает следующие значения:
#   f(-1) == -30
#   f(+1) == 28
# Из того, что функция на концах отрезка [-1, 1] принимает значения разного 
# знака следует, что в отрезке [-1, 1] f(x) содержит корень x0: f(x0) == 0.
#
# Необходимо написать функцию find_root(f, x_from, x_to, precision), которая 
# находит корень f(x) в отрезке [x_from, x_to] методом половинного деления [5] 
# с точностью precision.
#
# find_root должна сначала проверить, что на границах отрезка [x_from, x_to]
# f(x) принимает значения разного знака. Далее необходимо вычислить значение в
# середине отрезка x' = (x_from + x_to) / 2.0. Если f(x') == 0, то корень
# найден. Если f(x') того же знака, что и f(x_from), то корень находится в
# отрезке [x', x_to], иначе корень в отрезке [x_from, x'] --- длина отрезка,
# содержащего корень, сократилась в два раза. Будем продолжать искать корень на
# сокращённом отрезке до тех пор, пока длина отрезка не станет меньше
# precision, тогда в качестве корня можно вернуть значение середины последнего
# отрезка.
#
# Выведите найденное значение корня и значение функции в нём. Попробуйте искать
# корни различных несложных функций.

# Ссылки:
# [1] Число Пи: <http://ru.wikipedia.org/wiki/%D0%9F%D0%B8_%28%D1%87%D0%B8%D1%81%D0%BB%D0%BE%29>
# [2] itertools.count(): <http://docs.python.org/library/itertools.html#itertools.count>
# [3] xrange(): <http://docs.python.org/library/functions.html#xrange>
# [4] Число e: <https://ru.wikipedia.org/wiki/E_%28%D1%87%D0%B8%D1%81%D0%BB%D0%BE%29>
# [5] Метод половинного деления: <http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BF%D0%BE%D0%BB%D0%BE%D0%B2%D0%B8%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F>
